import type {
  AstNode,
  LiteralNode,
  IdentifierNode,
  UnaryNode,
  BinaryNode,
  MemberNode,
  ArrayNode,
  ObjectNode,
  ConditionalNode,
  DefNode,
  FunctionCallNode,
  LambdaNode,
  Grammar,
} from './types';

/**
 * The Evaluator takes an expression tree as generated by the
 * Parser and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate different
 * expressions, and does not have to be re-instantiated for each.
 * @param grammar A grammar map against which to evaluate the expression tree
 * @param [context] A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier. Any
 *      Promise values will be passed to the expression as their resolved
 *      value.
 * @param [args] arguments for lambda
 */
const NullSignal = {};

export function Evaluator(grammar: Grammar, context?: any, locals: Record<string, any> = {}, args?: any[]) {
  const handlers = {
    /**
     * Evaluates a Literal by returning its value property.
     * @param ast An expression tree with a Literal as its only node
     */
    Literal: (ast: LiteralNode) => ast.value,
    /**
     * Evaluates an Identifier by either stemming from the evaluated 'from'
     * expression tree or accessing the context provided when this Evaluator was
     * constructed.
     * @param ast An expression tree with an Identifier as the top node
     */
    Identifier: (ast: IdentifierNode) => {
      if (args && ast.argIndex !== undefined) return args[ast.argIndex];
      if (hasOwn(locals, ast.value)) return locals[ast.value];
      if (context == null) {
        throw new Error(`No context provided for evaluate`);
      }
      return context[ast.value];
    },
    /**
     * Evaluates a Unary expression by passing the right side through the
     * operator's eval function.
     * @param ast An expression tree with a Unary as the top node
     */
    Unary: (ast: UnaryNode) => {
      return grammar.unaryOps[ast.operator].fn(evaluate(ast.right));
    },
    /**
     * Evaluates a Binary node by running the Grammar's evaluator for
     * the given operator.
     * @param ast An expression tree with a Binary as the top
     *      node
     */
    Binary: (ast: BinaryNode) => {
      const binaryOp = grammar.binaryOps[ast.operator];
      return binaryOp.delay
        ? binaryOp.fn(evaluate(ast.left), () => evaluate(ast.right))
        : binaryOp.fn(evaluate(ast.left), evaluate(ast.right));
    },
    /**
     * Evaluates a Member by applying it to the subject value.
     * @param ast An expression tree with a Member as the top node
     * @param nullSignal optional chain null signal
     */
    Member: (ast: MemberNode, nullSignal?: boolean) => {
      const left = evaluate(ast.left, ast.leftOptional);
      if (left === NullSignal || (left == null && ast.optional)) {
        return nullSignal ? NullSignal : undefined;
      }
      if (left == null) {
        throw new Error(`Cannot read properties of ${left} (reading ${evaluate(ast.right)})`);
      }
      const key = evaluate(ast.right);
      if (Array.isArray(left) && key < 0) {
        return left[left.length + key];
      }
      return left[key];
    },
    /**
     * Evaluates an Array by returning its value, with each element
     * independently run through the evaluator.
     * @param ast An expression tree with an
     *      Object as the top node
     */
    Array: (ast: ArrayNode) => ast.value.map((item) => evaluate(item)),
    /**
     * Evaluates an Object by returning its value, with each key
     * independently run through the evaluator.
     * @param ast An expression tree with an Object as the top node
     */
    Object: (ast: ObjectNode) => {
      const result: any = {};
      ast.entries.forEach((entry) => {
        result[evaluate(entry.key)] = evaluate(entry.value);
      });
      return result;
    },
    /**
     * Evaluates a Conditional node by first evaluating its test branch,
     * and resolving with the consequent branch if the test is truthy, or the
     * alternate branch if it is not. If there is no consequent branch, the test
     * result will be used instead.
     * @param ast An expression tree with a Conditional as
     *      the top node
     */
    Conditional: (ast: ConditionalNode) => {
      const test = evaluate(ast.test);
      return test
        ? (ast.consequent ? evaluate(ast.consequent) : test)
        : evaluate(ast.alternate);
    },
    /**
     * Evaluates a FunctionCall node by applying a function from the transforms map or a Lambda or Context.
     * @param ast An expression tree with a Transform as the top node
     * @param nullSignal optional chain null signal
     */
    FunctionCall: (ast: FunctionCallNode, nullSignal?: boolean) => {
      const fn = ast.func.type === 'Identifier'
        ? (grammar.transforms[ast.func.value] || evaluate(ast.func, ast.leftOptional))
        : evaluate(ast.func, ast.leftOptional);
      if (fn === NullSignal || (fn == null && ast.optional)) {
        return nullSignal ? NullSignal : undefined;
      }
      if (typeof fn !== 'function') {
        throw new Error(`${fn} is not a function`);
      }
      const args = ast.args.map((item) => evaluate(item));
      return fn(...args);
    },
    /**
     * Evaluates a Lambda expression by passing the context merge with the args.
     * @param ast An expression tree with a Lambda as the top node
     * @returns A function of the Lambda
     */
    Lambda: (ast: LambdaNode) => {
      return (..._args: any[]) => {
        const evaluator = Evaluator(grammar, context, locals, _args);
        return evaluator.evaluate(ast.expr);
      };
    },
    Def: (ast: DefNode) => {
      const oldLocals = locals;
      locals = { ...locals };
      ast.defs.forEach((def) => {
        locals[def.name] = evaluate(def.value);
      });
      const result = evaluate(ast.statement);
      locals = oldLocals;
      return result;
    },
  };

  /**
   * Evaluates an expression tree within the configured context.
   * @param ast An expression tree object
   * @param [nullSignal] optional chain null signal
   * @returns the resulting value of the expression.
   */
  const evaluate = <T = any>(ast: AstNode, nullSignal?: boolean): T | undefined => {
    return handlers[ast.type](ast as any, nullSignal);
  };

  return { evaluate };
}

const hasOwn = (o: any, key: string) => Object.prototype.hasOwnProperty.call(o, key);
