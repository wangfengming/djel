import type {
  AstNode,
  LiteralNode,
  IdentifierNode,
  UnaryExpressionNode,
  BinaryExpressionNode,
  IndexExpressionNode,
  ArrayLiteralNode,
  ObjectLiteralNode,
  ConditionalExpressionNode,
  FunctionCallNode,
  LambdaNode,
  Grammar,
} from './types';

/**
 * The Evaluator takes an expression tree as generated by the
 * Parser and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate different
 * expressions, and does not have to be re-instantiated for each.
 * @param grammar A grammar map against which to evaluate the expression tree
 * @param [context] A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier. Any
 *      Promise values will be passed to the expression as their resolved
 *      value.
 */
export function Evaluator(grammar: Grammar, context?: any) {
  const handlers = {
    /**
     * Evaluates a Literal by returning its value property.
     * @param ast An expression tree with a Literal as its only node
     */
    Literal: (ast: LiteralNode) => ast.value,
    /**
     * Evaluates an Identifier by either stemming from the evaluated 'from'
     * expression tree or accessing the context provided when this Evaluator was
     * constructed.
     * @param ast An expression tree with an Identifier as the top node
     */
    Identifier: (ast: IdentifierNode) => context != null ? context[ast.value] : undefined,
    /**
     * Evaluates a Unary expression by passing the right side through the
     * operator's eval function.
     * @param ast An expression tree with a UnaryExpression as the top node
     */
    UnaryExpression: (ast: UnaryExpressionNode) => {
      return grammar.unaryOps[ast.operator].fn(evaluate(ast.right));
    },
    /**
     * Evaluates a BinaryExpression node by running the Grammar's evaluator for
     * the given operator.
     * @param ast An expression tree with a BinaryExpression as the top
     *      node
     */
    BinaryExpression: (ast: BinaryExpressionNode) => {
      const binaryOp = grammar.binaryOps[ast.operator];
      return binaryOp.delay
        ? binaryOp.fn(evaluate(ast.left), () => evaluate(ast.right))
        : binaryOp.fn(evaluate(ast.left), evaluate(ast.right));
    },
    /**
     * Evaluates a IndexExpression by applying it to the subject value.
     * @param ast An expression tree with a IndexExpression as the top node
     */
    IndexExpression: (ast: IndexExpressionNode) => {
      const left = evaluate(ast.left);
      if (left == null) return undefined;
      const key = evaluate(ast.right);
      if (Array.isArray(left) && key < 0) {
        return left[left.length + key];
      }
      return left[key];
    },
    /**
     * Evaluates an ArrayLiteral by returning its value, with each element
     * independently run through the evaluator.
     * @param ast An expression tree with an
     *      ObjectLiteral as the top node
     */
    ArrayLiteral: (ast: ArrayLiteralNode) => ast.value.map((item) => evaluate(item)),
    /**
     * Evaluates an ObjectLiteral by returning its value, with each key
     * independently run through the evaluator.
     * @param ast An expression tree with an ObjectLiteral as the top node
     */
    ObjectLiteral: (ast: ObjectLiteralNode) => {
      const result: any = {};
      ast.entries.forEach((entry) => {
        result[evaluate(entry.key)] = evaluate(entry.value);
      });
      return result;
    },
    /**
     * Evaluates a ConditionalExpression node by first evaluating its test branch,
     * and resolving with the consequent branch if the test is truthy, or the
     * alternate branch if it is not. If there is no consequent branch, the test
     * result will be used instead.
     * @param ast An expression tree with a ConditionalExpression as
     *      the top node
     */
    ConditionalExpression: (ast: ConditionalExpressionNode) => {
      const test = evaluate(ast.test);
      return test
        ? (ast.consequent ? evaluate(ast.consequent) : test)
        : evaluate(ast.alternate);
    },
    /**
     * Evaluates a FunctionCall node by applying a function from the transforms map or a Lambda or Context.
     * @param ast An expression tree with a Transform as the top node
     */
    FunctionCall: (ast: FunctionCallNode) => {
      const fn = ast.expr
        ? evaluate(ast.expr)
        : grammar.transforms[ast.name!];
      if (!fn) {
        throw new Error(`Cannot find transform ${ast.name}`);
      }
      const args = ast.args.map((item) => evaluate(item));
      return fn(...args);
    },
    /**
     * Evaluates a Lambda expression by passing the context merge with the args.
     * @param ast An expression tree with a Lambda as the top node
     * @returns A function of the Lambda
     */
    Lambda: (ast: LambdaNode) => {
      return (..._args: any[]) => {
        const newContext = { ...context };
        _args.forEach((arg, index) => {
          newContext[`@${index}`] = arg;
        });
        newContext['@'] = _args[0];
        const evaluator = Evaluator(grammar, newContext);
        return evaluator.evaluate(ast.expr);
      };
    },
  };

  /**
   * Evaluates an expression tree within the configured context.
   * @param ast An expression tree object
   * @returns the resulting value of the expression.
   */
  const evaluate = <T = any>(ast: AstNode): T => {
    return handlers[ast.type](ast as any);
  };

  return { evaluate };
}
